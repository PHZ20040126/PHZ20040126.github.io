---
title: SLAM(1)
date: 2024-10-03 10:45:51
tags:
    - 三维视觉
    - SLAM
    - 学习笔记
---
本文主要介绍SLAM最基础的纯视觉版本 ORB-SLAM。该版本SLAM通过单目相机，提取坐标中的特征点，循环检测以实现较为精准的定位。
### 补充知识
#### 词袋模型
对于一张图片进行词袋模型建立，需要一下三步:
1. 对于图像进行整体特征检测，投射入特征空间，然后进行聚类。
2. 对于聚类产生的类，取每个类的中心为一个单词。
3. 每次增加的图像增加的特征点加入特征空间，然后根据其对于各个类的距离进行分类.
   
由此实现对每张图的词袋表示。
#### 基于词袋模型的图像检索

对于图片的词袋模型搜索，常常采用TF-IDF(Term frequency(词频因子)-inverse document frequency(逆文档频率因子))
- 文档 *i* 中出现频率越高的词，其重要性越高。
- 数据库中包含单词 *j* 的文档越多，该单词对于文档的区分性越低，重要性也就越低。
$$
    t_j=\frac{n_{ij}}{n_i} \log(\frac{N}{n_j})
$$
在整个图像搜索过程中，采用倒排索引方法，索引值是特征编号，而不是图像编号。相对于图像所以，单词的数量在一定阈值后不会随着图像的增加而增加。故而其索引数量从图像数量N变成了特征点数量 $n_j$ 。同时在检索之后一般进行空间验证，以保证获取的点具有几何一致性，最终获取重排结果。

#### 优化问题
**ORB_SLAM**中的典型优化函数：
1. **GlobalBundleAdjustment** 除第一帧摄像机位置外，全部的地图点和关键帧相机优化(初始化)
2. **LocalBundleAdjustment** 优化部分地图点和关键帧的位姿
3. **PoseOptimization** 仅优化单帧摄像位姿(3D-2D重投影最小化、运动跟踪、参考帧跟踪、局部地图跟踪、重定位)
4. **OptimizeEssentialGraph** 本质图优化全部相机位姿(回环检测)
5. **OptimizeSim3** 优化两个关键帧和关键帧共有的地图点(回环检测)
#### 生成树
对于连通图进行遍历，过程中所经过的边和顶点的组合可以看做是一个普通树，通常成为生成树。
连通图中的生成树必须满足一下两个条件：
1. 包含连通图中的所有顶点
2. 任意两条顶点之间有且只有一条通路

### SLAM介绍
**Simultaneous Localization and Mapping (SLAM)**
- Localization：传感器的位置和姿态
- Mapping：地图构建
- SLAM：同时定位和建图
- 应用场景：定位，导航，避障，重建，交互

在整个地图构建的过程中，根据地图的特点可以分为：拓扑地图、2D栅格地图、3D网格地图、3D点云地图
  
### ORB-SLAM详解
在**ORB-SLAM**中
- 一般会同时运行三个线程：
  - 跟踪：确定当前帧位姿
  - 建图：完成局部地图构建
  - 回环修整：回环检测以及基于回环信息修正系统漂移
- 数据中心中，会存储
  1. 视觉词典
  2. 关键帧词袋数据库。
- 数据中心存储的数据包含
  1. 地图点
       - 世界坐标系下的3D坐标
       - 观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值
       - 最具表达性的ORB特征描述子
       - 该点能被观测到的最大距离和最小距离
  2. 关键帧
       - 摄像机位姿
       - 内参数
       - 全部ORB特征描述符，是否有地图点对应
  3. 共视图
       - 一种无向有全图，节点为关键帧，如果两个阶段共享的地图数大于阈值(至少15个)则存在一条边，其权重设置为共享地图的个数
  4. 本质图
       - 共视图的子图，保留所有节点，边数量相较于共视图更少，其作用是加速会还矫正的计算
        $本质图 = 生成树 + 共视图边权重超过100的边 + 回环边$
#### 跟踪
**目标**: 构建初始的地图点云，第一个摄像机作为世界坐标系。
  1. 计算特征点匹配，匹配数要大于预定义门限
  2. 同时计算基础矩阵F与单应矩阵H(注：匹配点可能来自同一平面)
  3. 分别计算F和H误差，选择最合理的矩阵
  4. 对F或者H进行分解，三角化重构出初始地图点
  5. 使用**GlobalBA**进行优化，即关键帧位姿与重构的地图点都参与优化

**基于前一帧的估计**：
  1. 如果前一帧跟踪成功，利用上一帧的运动模型估计当前帧的相机位姿
  2. 依据估计的R和T，将前一帧观测到的地图点投影到当前帧
  3. 如果成功找到足够多的点，则依照2D-3D对应点计算相机位姿(EPnP)；如果失败则转到全局重定位。  
  4. 在全局重定位中，计算当前帧的词袋，在数据库中进行检索，找到匹配度大于某个门限的候选参考关键帧，并对于每个候选参考关键帧进行特征点匹配和PnP计算操作，实现迭代优化，求解计算机位姿
  5. 
**局部地图跟踪：**
  1. 寻找候选“局部地图点”
     - 建立共视图中与当前帧相练的关键帧集合$K_1$以及与$K_1$相连的关键帧集合$K_2$
     - $K_1+K_2$看到的全部地图点构成"局部地图点"集合
     - $K_1$与当前帧相似度最高的设为$K_{ref}$
  2. 筛选地图点
     - 无法引申到当前帧的地图点舍弃
     - 当前点视图方向和该地图点的平均视图方向$n$满足$v*n < \cos(60^\circ)$ 
     - 计算地图点到该帧摄像机中心的距离$d$,如果$d \notin [d_{min}, d_{max}],则该地图点舍弃$
     - 计算尺度$\frac{d}{d_{min}}$，在该帧中，对于所有未匹配的ORB特征描述子，检测在该尺度下是否有3D点的投影与其匹配，若匹配则将该未匹配的特征描述子与3D点建立联系
  3. 使用所有未被筛选掉的2D-3D点对应当前帧进行位姿优化

**关键帧需要满足的条件：**
  1. 距离上次全局重定位已经经历了超过20帧(刚重定位的帧位姿可能不够准确)
  2.  局部地图线程空闲
  3.  或者距离上次关键帧插入超过了20帧(场景变化)
  4.  当前至少有50个关键点(该帧特征充足，可信度高)
  5.  当前帧和$K_{ref}$共视点相似比小于90%

#### 建图
**关键帧插入：**
- 更新共视图，增加新的节点$K_i$，更新共视图链接关系
- 更新生成树的节点关系
- 计算该新增关键帧的词袋表示，为新建地图点做准备

**地图点剔除**
- 最近增加的地图点必须通过如下测试，才可以留在地图中
  - 实际观测比例大于理论的25%
  - 地图点被创建后，再经过三个关键帧都可以观测到它
- 通过测试过的地图点，只在如下情况时会被删除
  - 任何时间下观测它的关键帧个数小于3(通常发生在删除关键帧时) 

**对于当前帧$K_I$中没有被特征匹配的特征点进行如下处理：**
  - 在共视图中选取共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配和三角化，对重构结果进行尺度、重投影误差、视差(不易过小)、正向深度检验。
  - 通过检验的点再投影到其他视图中，能匹配成功则建立“地图点-关键帧特征点”的对应关系。

**优化局部地图**
  - 当前帧(位姿)与共视关键帧(位姿)，及其它们看到的所有地图点(空间坐标)，参与局部BA优化。
  - 所有能看到上述地图点单与当前关键帧没有共视关系的关键帧参与局部BA，但它们的位姿在优化过程中固定不变。  

**局部关键帧剔除**
当场景不发生变化时，控制关键帧的数量。如果当前90%的地图点都可以被至少其他三个关键帧在相同或者更精细的尺度观测到，则该关键帧被剔除。

#### 回环修整
**回环候选帧检测**
  1. 回环候选关键帧产生
    - 在共视图中计算$K_i$与所邻居的BOW向量相似性，保存最低分数，记作$s_{min}$
    - 分数低于$s_{min}$的帧不做备选，与当前帧$K_i$直接相连的帧不做备选
  2. 确认回环关键帧
   
**对于每一个候选回环关键帧$K_j$**
  1. 计算其与当前关键帧$K_i$的特征匹配，建立3D-3D点对应
  2. 利用RANSAC方法估计其与当前帧的相似变换$S_{ij}$(7个自由度)
  3. 利用$S_{ij}$搜索两帧之间更多点对应
  4. 基于点对应优化$S_{ij}$直至有足够多内点，则接受当前候选回环关键帧，并记为$K_i$，其相似变换记为$S_{jl}$

**回环融合**
  1. 基于相似性矩阵$S_{il}$修正当前帧$K_i$(及其共视帧位姿)
  2. 特征点匹配与地图匹配融合：将回环帧$K_i$及其共视帧可见的地图点投影到当前帧$K_i$及其共视关键帧，寻找匹配并融合
  3. 连接关系更新:融合过程中涉及到的关键帧的边均需要更新，包括回环边
  - 每条边的误差为:
    $$
    e_{ij} = \log(S_{ij}S_{jw}S_{iw}^{-1})
    $$
  - 本质图上的总误差为：
    $$
    C = \sum_{i,j}{e_{i,j}^T\Lambda{e_{ij}}}    \\
    其中，{\Lambda}_{i,j}为单位矩阵
    $$


