---
title: 软件工程(1)
date: 2024-10-23 18:02:31
tags:
    - 学习笔记
---
### 软件生命周期模型
软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃位置，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。
如下是几种传统的模型种类：
1. **瀑布模型**
   - **特点**：瀑布模型按照严格的阶段顺序执行，每个阶段（需求分析、设计、编码、测试、维护）必须完成后才能进入下一阶段，后续阶段不能回溯。
   - **适用场景**：适用于需求明确且固定、开发流程清晰、变更较少的项目，如银行、政府系统等具有较高安全性和稳定性要求的项目。

2. **演化模型**
   - **特点**：该模型通过反复的迭代和反馈逐步完善软件，每次迭代后根据反馈改进设计和实现。
   - **适用场景**：适合需求不完全明确、需要频繁变更或改进的软件项目，如科研项目和快速变化的市场环境中的产品。

3. **增量模型**
   - **特点**：将整个系统的开发划分为多个增量，每个增量实现部分功能，最终通过多个增量的叠加构建完整系统。
   - **适用场景**：适用于需要快速交付部分功能的软件项目，如大型软件系统、复杂的企业应用，或需求不可能一次性完成的项目。

4. **喷泉模型**
   - **特点**：喷泉模型强调各个开发活动之间可以重叠进行，特别适合面向对象的开发。开发流程是连续的、迭代的，没有严格的阶段划分。
   - **适用场景**：多用于面向对象的开发项目，如使用面向对象语言（如Java或C++）开发的系统。

5. **V模型和W模型**
   - **特点**：V模型是瀑布模型的扩展，在开发阶段的每一步后都有相应的验证与确认活动；W模型进一步加强了测试的频率与覆盖范围。
   - **适用场景**：适用于对软件质量和测试要求高的项目，如医疗系统、航空软件等对测试和验证要求严格的场景。

6. **螺旋模型**
   - **特点**：螺旋模型结合了瀑布模型和迭代开发的优势，重点是风险管理，每次迭代都包括风险分析，并根据风险调整项目计划。
   - **适用场景**：适用于大型复杂项目或具有高风险因素的项目，如航天、国防系统开发。

7. **构件组装模型**
   - **特点**：通过复用现有的构件或模块，减少开发时间和成本，强调模块化设计和组装。
   - **适用场景**：适用于大型软件项目，特别是那些可以通过构件化的方式进行开发的系统，如企业级应用、ERP系统。

8. **快速应用开发模型**
   - **特点**：通过快速原型和频繁的用户反馈，缩短开发周期，快速交付功能齐全的产品版本。
   - **适用场景**：适用于对开发速度要求高且用户反馈至关重要的项目，如互联网应用、手机App开发。

9. **原型方法**
   - **特点**：先构建软件的初步原型，经过用户的评估和反馈，反复改进，直到最终产品满足需求。
   - **适用场景**：适合需求不明确或不完整的项目，或需要通过用户反馈不断优化的项目，如产品原型设计、用户界面开发等。

其中主要介绍瀑布模型、UP模型、喷泉模型和演化模型等
#### 瀑布模型
瀑布模型为软件开发和软件维护提供了一种有效的管理模式，它在软件开发早起为消除非结构化软件、降低软件复杂度、促进软件开发工程化起着显著作用。
其在不同开发阶段有不同的特征：
1. **需求分析阶段**：
   - **特征**：通过与客户沟通和分析业务需求，确定软件的功能需求和非功能需求，并形成详细的需求文档（Software Requirements Specification, SRS）。
   - **输出**：需求规格说明书（SRS），包含系统功能、性能、安全性等要求。

2. **系统设计阶段**：
   - **特征**：基于需求规格说明书进行系统架构设计，确定系统的模块划分、数据结构、接口设计等。分为概要设计（高层设计）和详细设计（低层设计）。
   - **输出**：系统设计文档，包含软件架构图、模块设计、数据库设计等内容。

3. **编码实现阶段**：
   - **特征**：根据系统设计文档，开发人员编写代码，完成各个模块的实现。代码需要遵循设计规范，并保证实现符合需求。
   - **输出**：源代码、可执行程序、代码注释和开发文档。

4. **测试阶段**：
   - **特征**：对编码后的软件进行测试，包括单元测试、集成测试、系统测试和验收测试，确保软件功能的正确性和性能的稳定性。测试通常依据需求规格说明书进行，验证是否满足所有要求。
   - **输出**：测试报告，包含测试用例、测试结果、缺陷报告等。

5. **部署与维护阶段**：
   - **特征**：将软件交付客户使用，并进行系统的安装和配置。维护包括修复错误、处理用户反馈、性能优化和系统升级。维护阶段可能需要多次修订和更新。
   - **输出**：用户手册、维护文档、补丁程序、更新版本。

其中共有的特征为:
- 本阶段的工作对象来自上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档
- 根据本阶段的活动规程执行相应的任务
- 产生本阶段活动相关产出，并将其作为下一阶段活动的输入
  
#### 演化模型
使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功
演化模型提倡两次开发：
  - 第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求
  - 第二次在此基础上获得较为满意的软件产品
  ![演化模型](/img/软件工程(1)/演化模型.png)
  演化模型一般适用于：
  - 需求不清楚
  - 小型或中小型系统
  - 开发周期短

#### 增量模型
首先对最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。再按照优先级逐步对后续的需求进行上述工作，逐步建成一个完整的开发方法。其**结合了瀑布模型和演化模型的优点**。 
![增量模型](/img/软件工程(1)/演化模型.png)

#### 喷泉模型
- 喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠，反复多次的。
- 各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求


#### V模型和W模型
相对于瀑布模型，V模型将测试活动提前，提高了其驾驭风险的能力，而W模型进一步加强了测试的频率与覆盖范围。
![V模型和W模型](/img/软件工程/V模型和W模型.png)

####
螺旋模型
螺旋模型主要针对大型软件项目的开发周期长、风险高的特点
![螺旋模型](/img/软件工程/螺旋模型.png)
螺旋模型本身含有四个象限内容：
  - 制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。
  - 风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施，规避这些风险。
  - 实施工程：针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动
  - 客户评价：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其周边开发过程进行评审，决定是否具备到下一个开发阶段的能力。

#### 构件组装模型
利用模块化思想将整个系统模块化，并在一定构建模型的支持下复用构件库中软件构件，通过组装高效率、高质量地构造软件系统。构建组装模型的本质上是演化的，开发过程是迭代的。
构建组装模型的开发过程就是构建组装的的过程，维护党的过程就是构件升级、替换和扩充的过程。
![构件组装模型](/img/软件工程(1)/构件组装模型.png)

#### 快速应用开发模型（RAD）
RAD是一个增量型的软件开发模型，强调极短的开发周期
![快速应用开发模型](/img/软件工程(1)/快速应用开发模型.png)






| 软件生命周期模型 | 优点                                                                                                                                                                                                                                                                                                                                                                 | 缺点                                                                                                                                                                                                                                      |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 瀑布模型         | 降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性 ； <br>推迟了软件实现，强调在软件实现前必须进行分析和设计工作；<br>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，保证了阶段之间的正确衔接； <br>能够及时发现并纠正开发过程中存在的缺陷，从而使产品达到预期的质量要求；                                                | 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题； <br>模型的风险控制能力较弱； <br>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加工作量； <br>管理人员可能根据文档评估进度产生错误结论；           |
| 演化模型         | 明确用户需求、提高系统质量、降低开发风险                                                                                                                                                                                                                                                                                                                             | 难于管理、结构较差、技术不成熟；<br>可能会抛弃瀑布模型文档控制的特点；<br>可能会导致最后的软件系统的系统结构较差                                                                                                                          |
| 增量模型         | 客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心；<br>项目总体失败的风险降低，因为核心功能线开发出来，即使某一次增量失败，核心功能的产品仍然可以使用；<br>由于增量是由按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要部分功能的可靠性；<br>所有增量都是在同一个体系结构指导下形成的，提高了系统稳定性和可维护性。 | 增量粒度难以选择；<br> 确定所有需求比较困难                                                                                                                                                                                               |
| 喷泉模型         | 提高开发效率；<br>缩短开发周期                                                                                                                                                                                                                                                                                                                                       | 难以管理，工作计划要随时更新                                                                                                                                                                                                              |
| 构件组装模型     | 充分利用软件复用，提高了软件开发效率；<br>允许多个项目同时开发，降低了效率，提高了可维护性，可实现分布提交软件产品                                                                                                                                                                                                                                                   | 缺乏通用的构件组装标准，风险较大； <br> 构件可重用性和高效性之间不可协调；<br> 由于过分依赖构件，构件指质量影响着最终的产品质量。                                                                                                         |
| 快速应用开发模型 |                                                                                                                                                                                                                                                                                                                                                                      | 并非所有应用都适合采用RAD；<br>由于时间约束，开发人员和客户必须在极短时间内完成一系列需求分析，沟通配合不当都会导致RAD模型的失败；<br>RAD适合于管理信息系统的开发，对于其他类型的系统，如技术风险较高、与外围系统互操作性较高等，不太合适 |




